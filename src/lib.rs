//! `byteview` provides [`byteview_owned!`](byteview_owned!) and [`byteview_ref!`](byteview_ref!) macros that
//! create structs that are thin "views" into owned or borrowed byte arrays.
//!
//! These are useful when parsing data or file formats where the following are true:
//! 1. You are not in control of the data format, but must parse data in an existing format.
//! 2. Most or all of the data is at fixed byte offsets.
//! 3. You often don't need to parse or use all of the data.
//! 4. You are ok with using some data even if other data is invalid.
//!
//! When using these macros, you declare a struct with fields corresponding to the bytes in the data format. The macro
//! will then generate a struct with the same name. However, the generated struct is simply a wrapper around a byte
//! array (owned or borrowed). Each declared field becomes a "getter" method implemented on the generated struct.
//!
//! Because the generated struct is a wrapper around a byte array, it can be used to implement zero-copy
//! deserialization. Creating an instance of the generated struct has no runtime cost, since it simply holds the
//! provided byte array.
//!
//! # Benefits
//!
//! - No eager parsing.
//!    - No bytes are parsed until they are used. This allows you to create structures with large amounts of data and
//!      only parse a small portion of it without needing to validate the entire structure.
//! - No out-of bounds errors.
//!    - Because the size of the generated struct is known at compile time and the struct contains a byte array of that
//!      size, there cannot be any out-of-bounds errors.
//! - Simple to use.
//!    - Using this crate typically involves the following simple steps:
//!       1. Define the data layout in a `byteview` macro.
//!       2. Retrieve some bytes.
//!       3. Create an instance of your struct with the bytes.
//!       4. Call one or more of the "getter" methods.
//! - No overhead.
//!    - If you have already read the bytes, then there is no overhead from creating instances of the generated structs.
//!      You only pay for parsing the fields you actually use at runtime.
//!
//! # Limitations
//!
//! - No eager parsing.
//!    - No bytes are parsed until they are used. This means that as long as you have enough bytes, nothing is stopping
//!      you from accidentally parsing data that is in completely the wrong format.
//! - Delayed field validation.
//!    - Since validation on fields is only performed when the fields are used, this can push validation errors deeper
//!      into your program instead of up-front before you start to use the data.
//! - Fields can only be primitive numeric types.
//!    - See the [next section](#more-than-primitive-numeric-types) for strategies on how to handle this limitation.
//! - Repeated validation/parsing.
//!    - Any parsing or validation that is done on the defined "fields" will be done every time the "getter" methods are
//!      called. The results of calling the "getter" methods are not cached.
//! - All bytes must be present when created.
//!    - All of the bytes must be present when instances of the generated struct are created. The generated structs do
//!      not support any form of streaming or partial construction. If desired, you can achieve results similar to
//!      streaming by creating structs for smaller "pieces" of the overall data, which can be processed independently as
//!      data is available.
//! - Size and structure must be known at compile time.
//!    - Neither the size nor the structure can depend on runtime data.
//! - No serialization.
//!    - Only deserialization is currently supported. Serialization may be added in the future but is not supported
//!      today.
//!
//! # More than primitive numeric types
//!
//! Although the field declarations must use primitive numeric types (or byte arrays), there are various strategies to
//! help deal with other types.
//!
//! The general strategy is to declare a private field/"getter" method and expose a public method that parses the raw
//! bytes/number.
//!
//! This example shows how to provide getter methods for bytes that encode a bool and an enum that look just like the
//! "getter" methods that return primitive numeric types.
//!
//! ```
//! byteview::byteview_owned! {
//!     struct Post {
//!         pub len: u32be, // This is already the appropriate type, no conversion necessary
//!         _is_public: u8, // This is a boolean field
//!         _state: u8,     // This is a State enum
//!     }
//! }
//!
//! impl Post {
//!     // Provide a public "getter" method that returns the appropriate type (bool).
//!     pub fn is_public(&self) -> bool {
//!         // Use the private "getter" method generated by byteview_owned!
//!         self._is_public() == 1
//!     }
//!
//!     // Provide a public "getter" method that returns the appropriate type (State). Since the conversion is fallible, we
//!     // wrap it in an Option.
//!     pub fn state(&self) -> Option<State> {
//!         // Use the private "getter" method generated by byteview_owned!
//!         Some(match self._state() {
//!             0 => State::Draft,
//!             1 => State::Scheduled,
//!             2 => State::Published,
//!             3 => State::Retracted,
//!             _ => return None,
//!         })
//!     }
//! }
//!
//! # #[derive(Debug, Eq, PartialEq)]
//! # enum State {
//! #     Draft,
//! #     Scheduled,
//! #     Published,
//! #     Retracted,
//! # }
//! #
//! let bytes = *b"\x00\x00\x00\x07\x01\x02";
//! let post = Post::from_array(bytes);
//! assert_eq!(7, post.len());
//! assert!(post.is_public());
//! assert_eq!(Some(State::Published), post.state());
//! ```
//!
//! Similar strategies can be used to include fields that are:
//!
//! - Strings
//!    - Parse a string from a fixed-size byte array field
//! - Nested data structures (including other structs generated by `byteview`)
//!    - Parse the nested data structure from a fixed-size byte array
//!
//! # Example
//!
//! ```
//! byteview::byteview_ref! {
//!     #[derive(Debug)]
//!     pub struct EntryHeaderRef {
//!         pub index: u32be, // Multi-byte primitive numeric type
//!         _kind: u8,        // Single byte
//!         _: u8,            // Single byte, unused
//!         _name: [u8; 16],  // Byte array
//!     }
//! }
//!
//! impl<'a> EntryHeaderRef<'a> {
//!     pub fn kind(&self) -> Option<Kind> {
//!         Some(match self._kind() {
//!             0 => Kind::Foo,
//!             1 => Kind::Bar,
//!             2 => Kind::Baz,
//!             _ => return None,
//!         })
//!     }
//!
//!     pub fn name(&self) -> &[u8] {
//!         let name = self._name();
//!         match name.into_iter().position(|b| *b == 0) {
//!             Some(i) => &name[..i],
//!             None => name,
//!         }
//!     }
//! }
//!
//! #[derive(Debug, Eq, PartialEq)]
//! pub enum Kind {
//!     Foo,
//!     Bar,
//!     Baz,
//! }
//!
//! let bytes = b"\x00\x00\x07\x01\x02\x2AMy Field Name\x00\x00\x00";
//! let entry_header = EntryHeaderRef::from_array(bytes);
//! assert_eq!(1793, entry_header.index());
//! assert_eq!(Some(Kind::Baz), entry_header.kind());
//! assert_eq!(b"My Field Name", entry_header.name());
//! ```
//!
//! # Comparison to other crates
//!
//! The `byteview` crate is similar in many ways to the [`zerocopy`] crate. The biggest difference is that `zerocopy`
//! does eager validation of all fields, while `byteview` only does validation when the "getter" methods are called.
//! However, `zerocopy` provides traits that allow can allow users to define how types are deserialized with less
//! boilerplate than `byteview`. In addition, `zerocopy` supports both serialization and deserialization, while
//! `byteview` only supports deserialization.
//!
//! The [`rkyv`] crate and others like it provide zero-copy deserialization but take full control of the format of the
//! serialized data. It cannot be used to deserialize data of arbitrary formats. `byteview` only supports
//! deserialization and requires the user to manually convert between any custom data types and raw bytes.
//!
//! [`zerocopy`]: https://docs.rs/zerocopy/latest/zerocopy/
//! [`rkyv`]: https://docs.rs/rkyv/latest/rkyv/
//!
//! # Other crates that may be useful
//!
//! There are several other crates that you may find useful when creating a parser for a data format. Here are a few
//! crates with ideas for how they would be beneficial.
//!
//! | Crate                          | Possible use case                                             |
//! | ------------------------------ | ------------------------------------------------------------- |
//! | [`static_assertions`]          | Assert that the size of the struct matches the expected size. |
//! | [`strum`] and [`strum_macros`] | Easily convert between integers and enums.                    |
//!
//! [`static_assertions`]: https://crates.io/crates/static_assertions
//! [`strum`]: https://crates.io/crates/strum
//! [`strum_macros`]: https://crates.io/crates/strum_macros

use proc_macro::TokenStream;
use quote::{ToTokens, TokenStreamExt, quote};
use std::str::FromStr;
use syn::parse::{Error, Parse};
use syn::spanned::Spanned;
use syn::{
    Attribute, Expr, Field, FieldMutability, Generics, Ident, ItemFn, ItemStruct, Type, TypeArray,
    TypePath, Visibility, parse, parse_macro_input, parse_quote,
};

//////////////////////////////////////////////////////////////////////
// Procedural Macro Wrappers
//////////////////////////////////////////////////////////////////////

/// Define a struct that is a thin "view" into a byte array reference, i.e. `&[u8; N]`.
///
/// # Motivation
///
/// This is especially useful for file or data formats where each item is at a fixed offset. By only processing the
/// bytes for an item when the item is requested, this can avoid processing large portions of the input data.
///
/// This requires the exact size be known at compile time. Items cannot be of a variable size, and there cannot be a
/// variable number of items. If there are a variable number of items, they must be constructed separately with a
/// distinct type.
///
/// # Usage
///
/// This macro expects a struct declaration. The permitted field types are:
/// 1. A single byte, i.e. [`u8`] or [`i8`].
/// 2. Any other primitive integer or floating-point numeric type along with an "endianness" suffix: "be" (big endian),
///    "le" (little endian), or "ne" (native endian).
///    - E.g. `u16be` (big-endian `u16`), `i32le` (little-endian `i32`), `f64ne` (native-endian `f64`), etc.
/// 3. An array of bytes, i.e. `[u8; N]` where `N` is a `const` `usize`.
///
/// # Generated Code
///
/// The macro generates a struct with the provided name. The struct will be a one-element struct that wraps a byte array
/// reference. The size of the array is calculated by summing the sizes of all fields in the original struct
/// declaration.
///
/// The fields in the original struct declaration will be used to create "getter" methods. Each methods return the
/// appropriate byte or bytes from the wrapped byte array. If the field is a multi-byte primitive, it will return the
/// result of the appropriate "from_bytes" method (e.g. [`u32::from_be_bytes`]).
///
/// The visibility of each "getter" method will be the same as the visibility of the field in the original struct
/// declaration. Similarly, any annotations attached to the original field (including doc comments) will be attached to
/// the corresponding "getter" method.
///
/// If there are bytes in the data format that are unused or ignored, they must still be accounted for in the struct
/// declaration to ensure subsequent fields have the correct offset and the overall struct has the correct size.
/// However, these fields can be "ignored" by using a field name of `_`. Any field with the name `_` will not produce a
/// "getter" method but _will_ be used when calculating offsets and the total size.
///
/// # Examples
///
/// ```
/// byteview::byteview_ref! {
///     /// The header for an entry (borrowed).
///     #[derive(Debug)]
///     pub struct EntryHeaderRef {
///         /// The index of the entry.
///         pub index: u32be,
///         _kind: u8,
///         _: u8,
///         _name: [u8; 16],
///     }
/// }
///
/// impl<'a> EntryHeaderRef<'a> {
///     /// What [`Kind`] of entry this is.
///     pub fn kind(&self) -> Option<Kind> {
///         Some(match self._kind() {
///             0 => Kind::Foo,
///             1 => Kind::Bar,
///             2 => Kind::Baz,
///             _ => return None,
///         })
///     }
///
///     /// The name of the entry.
///     pub fn name(&self) -> &[u8] {
///         let name = self._name();
///         match name.into_iter().position(|b| *b == 0) {
///             Some(i) => &name[..i],
///             None => name,
///         }
///     }
/// }
///
/// #[derive(Debug, Eq, PartialEq)]
/// pub enum Kind {
///     Foo,
///     Bar,
///     Baz,
/// }
///
/// let bytes = b"\x00\x00\x07\x01\x02\x2AMy Field Name\x00\x00\x00";
/// let entry_header = EntryHeaderRef::from_array(bytes);
/// assert_eq!(1793, entry_header.index());
/// assert_eq!(Some(Kind::Baz), entry_header.kind());
/// assert_eq!(b"My Field Name", entry_header.name());
/// ```
#[proc_macro]
pub fn byteview_ref(input: TokenStream) -> TokenStream {
    byteview_ref_impl(input)
}

/// Define a struct that is a thin "view" into an owned byte array, i.e. `[u8; N]`.
///
/// # Motivation
///
/// This is especially useful for file or data formats where each item is at a fixed offset. By only processing the
/// bytes for an item when the item is requested, this can avoid processing large portions of the input data.
///
/// This requires the exact size be known at compile time. Items cannot be of a variable size, and there cannot be a
/// variable number of items. If there are a variable number of items, they must be constructed separately with a
/// distinct type.
///
/// # Usage
///
/// This macro expects a struct declaration. The permitted field types are:
/// 1. A single byte, i.e. [`u8`] or [`i8`].
/// 2. Any other primitive integer or floating-point numeric type along with an "endianness" suffix: "be" (big endian),
///    "le" (little endian), or "ne" (native endian).
///    - E.g. `u16be` (big-endian `u16`), `i32le` (little-endian `i32`), `f64ne` (native-endian `f64`), etc.
/// 3. An array of bytes, i.e. `[u8; N]` where `N` is a `const` `usize`.
///
/// # Generated Code
///
/// The macro generates a struct with the provided name. The struct will be a one-element struct that wraps an owned
/// byte array. The size of the array is calculated by summing the sizes of all fields in the original struct
/// declaration.
///
/// The fields in the original struct declaration will be used to create "getter" methods. Each method returns the
/// appropriate byte or bytes from the wrapped byte array. If the field is a multi-byte primitive, it will return the
/// result of the appropriate "from_bytes" method (e.g. [`u32::from_be_bytes`]).
///
/// The visibility of each "getter" method will be the same as the visibility of the field in the original struct
/// declaration. Similarly, any annotations attached to the original field (including doc comments) will be attached to
/// the corresponding "getter" method.
///
/// If there are bytes in the data format that are unused or ignored, they must still be accounted for in the struct
/// declaration to ensure subsequent fields have the correct offset and the overall struct has the correct size.
/// However, these fields can be "ignored" by using a field name of `_`. Any field with the name `_` will not produce a
/// "getter" method but _will_ be used when calculating offsets and the total size.
///
/// # Examples
///
/// ```
/// byteview::byteview_owned! {
///     /// The header for an entry (owned).
///     #[derive(Debug)]
///     pub struct EntryHeaderOwned {
///         /// The index of the entry.
///         pub index: u32be,
///         _kind: u8,
///         _: u8,
///         _name: [u8; 16],
///     }
/// }
///
/// impl EntryHeaderOwned {
///     /// What [`Kind`] of entry this is.
///     pub fn kind(&self) -> Option<Kind> {
///         Some(match self._kind() {
///             0 => Kind::Foo,
///             1 => Kind::Bar,
///             2 => Kind::Baz,
///             _ => return None,
///         })
///     }
///
///     /// The name of the entry.
///     pub fn name(&self) -> &[u8] {
///         let name = self._name();
///         match name.into_iter().position(|b| *b == 0) {
///             Some(i) => &name[..i],
///             None => name,
///         }
///     }
/// }
///
/// #[derive(Debug, Eq, PartialEq)]
/// pub enum Kind {
///     Foo,
///     Bar,
///     Baz,
/// }
///
/// let bytes = *b"\x00\x00\x07\x01\x02\x2AMy Field Name\x00\x00\x00";
/// let entry_header = EntryHeaderOwned::from_array(bytes);
/// assert_eq!(1793, entry_header.index());
/// assert_eq!(Some(Kind::Baz), entry_header.kind());
/// assert_eq!(b"My Field Name", entry_header.name());
/// ```
#[proc_macro]
pub fn byteview_owned(input: TokenStream) -> TokenStream {
    byteview_owned_impl(input)
}

//////////////////////////////////////////////////////////////////////
// Constants
//////////////////////////////////////////////////////////////////////

const UNSUPPORTED_TYPE_MESSAGE: &str =
    "Unsupported type (see byteview documentation for supported types)";

//////////////////////////////////////////////////////////////////////
// Data Structures
//////////////////////////////////////////////////////////////////////

#[derive(Debug)]
struct ByteViewStruct {
    attrs: Vec<Attribute>,
    vis: Visibility,
    ident: Ident,
    fields: Vec<ByteViewField>,
}

#[derive(Debug)]
struct ByteViewField {
    attrs: Vec<Attribute>,
    vis: Visibility,
    ident: Ident,
    byteview_type: ByteViewType,
}

#[derive(Debug)]
enum ByteViewType {
    SingleByte(Signedness),
    MultiByte(MultiByteType, Endianness),
    Array(Expr),
}

#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
enum Signedness {
    Unsigned,
    Signed,
}

#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
enum MultiByteType {
    U16,
    U32,
    U64,
    U128,
    I16,
    I32,
    I64,
    I128,
    F32,
    F64,
}

#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
enum Endianness {
    Big,
    Little,
    Native,
}

//////////////////////////////////////////////////////////////////////
// Parsing Tokens
//////////////////////////////////////////////////////////////////////

impl Parse for ByteViewStruct {
    fn parse(input: parse::ParseStream) -> syn::Result<Self> {
        let raw_struct = input.parse::<ItemStruct>()?;
        let ItemStruct {
            attrs,
            vis,
            ident,
            generics,
            fields,
            ..
        } = raw_struct;
        if !generics.params.is_empty() {
            return Err(Error::new(
                generics.params.span(),
                "Generics are not permitted on byteview struct definitions".to_string(),
            ));
        }
        if let Some(where_clause) = generics.where_clause {
            return Err(Error::new(
                where_clause.span(),
                "Generic types are not permitted on byteview struct definitions".to_string(),
            ));
        };
        let fields: Vec<ByteViewField> = fields
            .into_iter()
            .map(TryFrom::try_from)
            .collect::<Result<_, _>>()?;
        Ok(Self {
            attrs,
            vis,
            ident,
            fields,
        })
    }
}

impl Parse for ByteViewField {
    fn parse(input: parse::ParseStream) -> syn::Result<Self> {
        let field = Field::parse_named(input)?;
        Self::try_from(field)
    }
}

impl TryFrom<Field> for ByteViewField {
    type Error = syn::Error;

    fn try_from(field: Field) -> std::result::Result<Self, Self::Error> {
        let field_span = field.span();
        let Field {
            attrs,
            vis,
            mutability,
            ident,
            colon_token: _,
            ty,
        } = field;
        // Future proof
        let FieldMutability::None = mutability else {
            return Err(Error::new(
                field_span,
                "Field mutability restrictions are not supported".to_owned(),
            ));
        };
        let ident = ident.expect("Field must be named; tuple structs are not permitted");
        let byteview_type = ByteViewType::try_from(ty)?;
        Ok(Self {
            attrs,
            vis,
            ident,
            byteview_type,
        })
    }
}

impl TryFrom<Type> for ByteViewType {
    type Error = syn::Error;

    fn try_from(ty: Type) -> Result<Self, Self::Error> {
        match ty {
            Type::Path(type_path) => Self::try_from(type_path),
            Type::Array(type_array) => Self::try_from(type_array),
            Type::Paren(type_paren) => {
                let span = type_paren.span();
                Self::try_from(*type_paren.elem).map_err(|e| Error::new(span, e.to_string()))
            }
            Type::Slice(type_slice) => {
                Err(Error::new(
                    type_slice.span(),
                    "Length must be provided at compile time".to_owned(),
                ))
            }
            value => {
                Err(Error::new(value.span(), UNSUPPORTED_TYPE_MESSAGE))
            }
        }
    }
}

impl TryFrom<TypeArray> for ByteViewType {
    type Error = syn::Error;

    fn try_from(array: TypeArray) -> Result<Self, Self::Error> {
        let TypeArray {
            bracket_token: _,
            elem,
            semi_token: _,
            len,
        } = array;
        let span = elem.span();
        let err = || Err(Error::new(span, "Must be an array of u8".to_owned()));
        let Type::Path(type_path) = *elem else {
            return err();
        };
        let Some(ident) = type_path.path.get_ident() else {
            return err();
        };
        if *ident != "u8" {
            return err();
        }
        Ok(Self::Array(len))
    }
}

impl TryFrom<TypePath> for ByteViewType {
    type Error = syn::Error;

    fn try_from(type_path: TypePath) -> Result<Self, Self::Error> {
        let span = type_path.span();
        let error = || Error::new(span, UNSUPPORTED_TYPE_MESSAGE);
        let err = || Err(error());
        let ident_str = type_path.path.require_ident()?.to_string();
        match ident_str.as_str() {
            "u8" => return Ok(Self::SingleByte(Signedness::Unsigned)),
            "u8be" | "u8le" | "u8ne" => {
                return Err(Error::new(
                    span,
                    "u8 does not need endianness specifier".to_string(),
                ));
            }
            "i8" => return Ok(Self::SingleByte(Signedness::Signed)),
            "i8be" | "i8le" | "i8ne" => {
                return Err(Error::new(
                    span,
                    "i8 does not need endianness specifier".to_string(),
                ));
            }
            _ => {}
        }

        let (type_string, endianness_string) = split_type_endianness_strings(&ident_str);

        let multi_byte_type = type_string
            .as_str()
            .parse::<MultiByteType>()
            .map_err(|_| error())?;

        let endianness = match endianness_string.as_str() {
            "be" => Endianness::Big,
            "le" => Endianness::Little,
            "ne" => Endianness::Native,
            "" => {
                return Err(Error::new(
                    span,
                    format!(
                        "Endianness required, use {0}be, {0}le, or {0}ne",
                        type_string
                    ),
                ));
            }
            _ => return err(),
        };

        Ok(Self::MultiByte(multi_byte_type, endianness))
    }
}

// Split a type + endianness string. This is expected to be the name of a support multi-byte type name (see
// MultiByteType) followed by an endianness string (see Endianness). This function naively splits the string into two
// pieces: 1) the string before and including any digits and 2) the string after the first set of consecutive digits.
fn split_type_endianness_strings(ident_str: &str) -> (String, String) {
    // This is slightly unwieldly, but my ideas for how to make it more succinct all involve the regex crate or the
    // itertools crate. I would like to avoid taking on such large dependencies just for this one thing.
    let mut chars = ident_str.chars();
    let mut type_chars = Vec::new();
    let mut endianness_chars = Vec::new();
    let mut seen_digit = false;
    for c in chars.by_ref() {
        if c.is_ascii_digit() {
            seen_digit = true;
            type_chars.push(c);
        } else if seen_digit {
            endianness_chars.push(c);
            break;
        } else {
            type_chars.push(c);
        }
    }
    endianness_chars.extend(chars);

    (
        type_chars.into_iter().collect(),
        endianness_chars.into_iter().collect(),
    )
}

//////////////////////////////////////////////////////////////////////
// Constructing Tokens
//////////////////////////////////////////////////////////////////////

// Whether the inner bytes are borrowed or owned.
#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
enum ByteViewFieldKind {
    Borrowed,
    Owned,
}

// The ByteViewStruct + FieldKind. This custom struct makes it easy to implement the ToTokens trait, which in turn
// makes it easy to implement the proc_macro(s).
#[derive(Debug)]
struct ByteViewStructTagged {
    inner: ByteViewStruct,
    field_kind: ByteViewFieldKind,
}

impl ToTokens for ByteViewStructTagged {
    fn to_tokens(&self, tokens: &mut proc_macro2::TokenStream) {
        let Self { inner, field_kind } = self;
        let ByteViewStruct {
            attrs,
            vis,
            ident,
            fields,
        } = inner;

        let (getters, total_size_expr) = create_getters_and_total_size_expr(fields);
        let bytes_type = field_kind.create_bytes_type(ident);
        let constructors = field_kind.create_constructors(ident);
        let lifetime_annotation = field_kind.create_lifetime_annotation();
        let num_bytes_doc = format!("The total number of bytes contained in a [`{ident}`].");

        let token_stream = quote! {
            #(#attrs)*
            #vis struct #ident #lifetime_annotation {
                bytes: #bytes_type,
            }

            impl #lifetime_annotation #ident #lifetime_annotation {
                #[doc = #num_bytes_doc]
                pub const NUM_BYTES: usize = #total_size_expr;

                #(#constructors)*

                #(#getters)*
            }
        };

        tokens.append_all(token_stream);
    }
}

// Create a list of "getter" functions for each ByteViewField. The "getter" will extract the bytes at the appropriate
// offsets, which requires keeping a running tally of the cumulative length so far. Return the created "getter"
// functions along with the final cumulative length, which is the total size required for the struct.
fn create_getters_and_total_size_expr(fields: &[ByteViewField]) -> (Vec<ItemFn>, Expr) {
    let mut cur_offset_expr: Expr = parse_quote! { 0 };
    let mut getters = Vec::new();
    for field in fields {
        let size = field.byteview_type.get_size_expr(); // unnecessary clone
        let next_offset_expr = parse_quote! { #cur_offset_expr + #size };
        getters.extend(field.create_getter(&cur_offset_expr));
        cur_offset_expr = next_offset_expr;
    }
    let total_size_expr = cur_offset_expr;
    (getters, total_size_expr)
}

impl ByteViewField {
    // Create a "getter" function for the field. The method should extract the appropriate number of bytes at the given
    // offset from the inner `self.bytes` field. As a special case, if the field name is "_" then do not create a
    // function, since "_" is not a valid identifier. Users can use the "_" pattern to create "padding" bytes that have
    // no meaning but need to be there so later bytes are at the correct offsets.
    fn create_getter(&self, offset_expr: &Expr) -> Option<ItemFn> {
        let ByteViewField {
            attrs,
            vis,
            ident,
            byteview_type: ty,
        } = self;

        if *ident == "_" {
            // A single underscore is not an identifier (see
            // https://doc.rust-lang.org/reference/identifiers.html#r-ident.profile). Allow users to use them as
            // placeholders for "padding", but do not create getter methods.
            return None;
        }
        let body: Expr = ty.create_getter_expr(offset_expr);
        let return_type = ty.get_type();
        Some(parse_quote! {
            #(#attrs)*
            #vis fn #ident(&self) -> #return_type {
                #body
            }
        })
    }
}

impl ByteViewType {
    fn get_type(&self) -> Type {
        match self {
            ByteViewType::SingleByte(Signedness::Unsigned) => parse_quote! { u8 },
            ByteViewType::SingleByte(Signedness::Signed) => parse_quote! { i8 },
            ByteViewType::MultiByte(multi_byte_type, _) => multi_byte_type.get_type(),
            ByteViewType::Array(expr) => parse_quote! { &[u8; #expr] },
        }
    }

    fn get_size_expr(&self) -> Expr {
        match self {
            Self::SingleByte(_) => parse_quote! { 1 },
            Self::Array(expr) => expr.clone(),
            Self::MultiByte(multi_byte_type, _) => {
                let size = multi_byte_type.get_size();
                parse_quote! { #size }
            }
        }
    }

    // Create an expression that gets the appropriate bytes from the inner `self.bytes` field.
    fn create_getter_expr(&self, offset_expr: &Expr) -> Expr {
        match self {
            ByteViewType::SingleByte(Signedness::Unsigned) => {
                parse_quote! { self.bytes[#offset_expr] }
            }
            ByteViewType::SingleByte(Signedness::Signed) => {
                parse_quote! { self.bytes[#offset_expr] as i8 }
            }
            ByteViewType::MultiByte(multi_byte_type, endianness) => {
                let type_name = multi_byte_type.get_type_name();
                let function_name = endianness.create_from_bytes_function_name();
                let size = multi_byte_type.get_size();
                let start = offset_expr;
                let end: Expr = parse_quote! { #start + #size };
                parse_quote! {
                    ::std::primitive::#type_name::#function_name(::std::result::Result::expect(::core::convert::TryInto::<[u8; #size]>::try_into(&self.bytes[#start..#end]), "invalid indices"))
                }
            }
            ByteViewType::Array(size) => {
                let start = offset_expr;
                let end: Expr = parse_quote! { #offset_expr + #size };
                parse_quote! {
                    ::std::result::Result::expect(::core::convert::TryInto::<&[u8; #size]>::try_into(&self.bytes[#start..#end]), "invalid indices")
                }
            }
        }
    }
}

impl MultiByteType {
    fn get_size(self) -> usize {
        match self {
            MultiByteType::U16 => 2,
            MultiByteType::U32 => 4,
            MultiByteType::U64 => 8,
            MultiByteType::U128 => 16,
            MultiByteType::I16 => 2,
            MultiByteType::I32 => 4,
            MultiByteType::I64 => 8,
            MultiByteType::I128 => 16,
            MultiByteType::F32 => 4,
            MultiByteType::F64 => 8,
        }
    }

    fn get_type(self) -> Type {
        self.parse_type_name()
    }

    fn get_type_name(self) -> Ident {
        self.parse_type_name()
    }

    // This is a helper function that is generic over the output T. It can be used to parse any kind of syn item by
    // using the type name. This could be, for example, a syn::Ident or a syn::Type.
    fn parse_type_name<T>(self) -> T
    where
        T: Parse,
    {
        match self {
            MultiByteType::U16 => parse_quote! { u16 },
            MultiByteType::U32 => parse_quote! { u32 },
            MultiByteType::U64 => parse_quote! { u64 },
            MultiByteType::U128 => parse_quote! { u128 },
            MultiByteType::I16 => parse_quote! { i16 },
            MultiByteType::I32 => parse_quote! { i32 },
            MultiByteType::I64 => parse_quote! { i64 },
            MultiByteType::I128 => parse_quote! { i128 },
            MultiByteType::F32 => parse_quote! { f32 },
            MultiByteType::F64 => parse_quote! { f64 },
        }
    }
}

impl FromStr for MultiByteType {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(match s {
            "u16" => MultiByteType::U16,
            "u32" => MultiByteType::U32,
            "u64" => MultiByteType::U64,
            "u128" => MultiByteType::U128,
            "i16" => MultiByteType::I16,
            "i32" => MultiByteType::I32,
            "i64" => MultiByteType::I64,
            "i128" => MultiByteType::I128,
            "f32" => MultiByteType::F32,
            "f64" => MultiByteType::F64,
            _ => return Err(s.to_owned()),
        })
    }
}

impl Endianness {
    // Create a function name for the appropriate getter function for this endianness. This takes advantage of the fact
    // that all of the supported multi-byte types have the same name for the functions that convert byte arrays to their
    // corresponding type. These are not trait methods, so there is no requirement for them to be the same, but since
    // they _are_ the same, we can use the same function name for all of the supported types.
    fn create_from_bytes_function_name(self) -> Ident {
        match self {
            Endianness::Big => parse_quote! { from_be_bytes },
            Endianness::Little => parse_quote! { from_le_bytes },
            Endianness::Native => parse_quote! { from_ne_bytes },
        }
    }
}

impl ByteViewFieldKind {
    fn create_bytes_type(self, ident: &Ident) -> Type {
        match self {
            ByteViewFieldKind::Borrowed => {
                parse_quote! { &'a [::std::primitive::u8; #ident::NUM_BYTES] }
            }
            ByteViewFieldKind::Owned => parse_quote! { [::std::primitive::u8; #ident::NUM_BYTES] },
        }
    }

    // Create the various constructors for this kind of field. For FieldKind::Borrowed, the input will be a reference to
    // a byte array/slice. For FieldKind::Owned, the input will be an owned byte array/Vec.
    fn create_constructors(self, ident: &Ident) -> Vec<ItemFn> {
        match self {
            ByteViewFieldKind::Borrowed => create_constructors_for_borrowed(ident),
            ByteViewFieldKind::Owned => create_constructors_for_owned(ident),
        }
    }

    // Create the appropriate lifetime annotation. This will be a <'a> if the bytes field is borrowed and nothing if the
    // bytes field is owned.
    fn create_lifetime_annotation(self) -> Generics {
        match self {
            ByteViewFieldKind::Borrowed => parse_quote! { <'a> },
            ByteViewFieldKind::Owned => parse_quote! {},
        }
    }
}

// Create the appropriate constructors if the bytes field is borrowed.
fn create_constructors_for_borrowed(ident: &Ident) -> Vec<ItemFn> {
    let from_array_doc = format!(
        "Create a [`{ident}`] from a reference to an array of [`NUM_BYTES`][{ident}::NUM_BYTES] bytes."
    );
    let from_array = parse_quote! {
        #[doc = #from_array_doc]
        pub fn from_array(bytes: &'a [::std::primitive::u8; #ident::NUM_BYTES]) -> Self {
            Self { bytes }
        }
    };

    let from_exact_slice_doc = format!(
        "Create a [`{ident}`] from a slice of [`NUM_BYTES`][{ident}::NUM_BYTES] bytes.\n\
        \n\
        If the slice does not contain exactly [`NUM_BYTES`][{ident}::NUM_BYTES], return [`Option::None`]."
    );
    let from_exact_slice = parse_quote! {
        #[doc = #from_exact_slice_doc]
        pub fn from_exact_slice(bytes: &'a [::std::primitive::u8]) -> ::std::option::Option<Self> {
            Some(Self { bytes: ::std::convert::TryInto::try_into(bytes).ok()? })
        }

    };

    let split_slice_doc = format!(
        "Create a [`{ident}`] from the first [`NUM_BYTES`][{ident}::NUM_BYTES] bytes of a slice and return it along with the remaining bytes.\n\
        \n\
        If the slice does not contain at least [`NUM_BYTES`][{ident}::NUM_BYTES] bytes, return [`Option::None`]."
    );
    let split_slice = parse_quote! {
        #[doc = #split_slice_doc]
        pub fn split_slice(bytes: &'a [::std::primitive::u8]) -> ::std::option::Option<(Self, &'a [::std::primitive::u8])> {
            let (exact_bytes, rest_bytes) = bytes.split_at_checked(#ident::NUM_BYTES)?;
            Some((Self { bytes: ::std::convert::TryInto::try_into(exact_bytes).ok()? }, rest_bytes))
        }
    };

    vec![from_array, from_exact_slice, split_slice]
}

// Create the appropriate constructors if the bytes field is owned.
fn create_constructors_for_owned(ident: &Ident) -> Vec<ItemFn> {
    let from_array_doc =
        format!("Create a [`{ident}`] from an array of [`NUM_BYTES`][{ident}::NUM_BYTES] bytes.");
    let from_array = parse_quote! {
        #[doc = #from_array_doc]
        pub fn from_array(bytes: [::std::primitive::u8; #ident::NUM_BYTES]) -> Self {
            Self { bytes }
        }
    };

    let from_exact_vec_doc = format!(
        "Create a [`{ident}`] from a [`Vec`] of [`NUM_BYTES`][{ident}::NUM_BYTES] bytes.\n\
        \n\
        If the `Vec` does not contain exactly [`NUM_BYTES`][{ident}::NUM_BYTES], return [`Option::None`]."
    );
    let from_exact_vec = parse_quote! {
        #[doc = #from_exact_vec_doc]
        pub fn from_exact_vec(bytes: Vec<u8>) -> Option<Self> {
            Some(Self { bytes: bytes.try_into().ok()? })
        }
    };

    let split_vec_doc = format!(
        "Create a [`{ident}`] from the first [`NUM_BYTES`][{ident}::NUM_BYTES] bytes of a [`Vec`] and return it along with the remaining bytes.\n\
        \n\
        If the [`Vec`] does not contain at least [`NUM_BYTES`][{ident}::NUM_BYTES] bytes, return [`Option::None`]."
    );
    let split_vec = parse_quote! {
        #[doc = #split_vec_doc]
        pub fn split_vec(mut bytes: Vec<u8>) -> Option<(Self, Vec<u8>)> {
            if bytes.len() < Self::NUM_BYTES {
                return None;
            }
            let rest = bytes.split_off(Self::NUM_BYTES);
            Some((Self { bytes: bytes.try_into().ok()? }, rest))
        }
    };

    vec![from_array, from_exact_vec, split_vec]
}

//////////////////////////////////////////////////////////////////////
// Procedural Macro Implementations
//////////////////////////////////////////////////////////////////////

fn byteview_ref_impl(input: TokenStream) -> TokenStream {
    let byteview_struct = parse_macro_input!(input as ByteViewStruct);
    let byteview_struct_tagged = ByteViewStructTagged {
        inner: byteview_struct,
        field_kind: ByteViewFieldKind::Borrowed,
    };
    quote! {
        #byteview_struct_tagged
    }
    .into()
}

fn byteview_owned_impl(input: TokenStream) -> TokenStream {
    let byteview_struct = parse_macro_input!(input as ByteViewStruct);
    let byteview_struct_tagged = ByteViewStructTagged {
        inner: byteview_struct,
        field_kind: ByteViewFieldKind::Owned,
    };
    quote! {
        #byteview_struct_tagged
    }
    .into()
}

//////////////////////////////////////////////////////////////////////
// Tests
//////////////////////////////////////////////////////////////////////
#[cfg(test)]
mod test {
    use super::*;

    #[test]
    pub fn single_underscore_field_name() {
        let tokens = quote! {
            struct Foo {
                x: u8,
                y: u16be,
                z: [u8; 3],
                _: u8,
            }
        };

        let byteview_struct: Result<ByteViewStruct, _> = syn::parse2(tokens);
        assert!(byteview_struct.is_ok());
        let byteview_struct = byteview_struct.unwrap();
        let tagged = ByteViewStructTagged {
            inner: byteview_struct,
            field_kind: ByteViewFieldKind::Borrowed,
        };

        quote! { #tagged };
    }

    #[test]
    pub fn ref_field() {
        // Use a raw string here so we can look at the span byte offsets if needed
        let s = "struct Foo { x: &[u8; 32], }";
        let tokens: proc_macro2::TokenStream = s.parse().unwrap();

        let byteview_struct: Result<ByteViewStruct, _> = syn::parse2(tokens);
        assert!(byteview_struct.is_err());
    }
}
