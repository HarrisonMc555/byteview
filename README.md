# byteview

`byteview` provides [`byteview_owned!`](byteview_owned!) and [`byteview_ref!`](byteview_ref!) macros that
create structs that are thin "views" into owned or borrowed byte arrays.

These are useful when parsing data or file formats where the following are true:
1. You are not in control of the data format, but must parse data in an existing format.
2. Most or all of the data is at fixed byte offsets.
3. You often don't need to parse or use all of the data.
4. You are ok with using some data even if other data is invalid.

When using these macros, you declare a struct with fields corresponding to the bytes in the data format. The macro
will then generate a struct with the same name. However, the generated struct is simply a wrapper around a byte
array (owned or borrowed). Each declared field becomes a "getter" method implemented on the generated struct.

Because the generated struct is a wrapper around a byte array, it can be used to implement zero-copy
deserialization. Creating an instance of the generated struct has no runtime cost, since it simply holds the
provided byte array.

## Benefits

- No eager parsing.
   - No bytes are parsed until they are used. This allows you to create structures with large amounts of data and
     only parse a small portion of it without needing to validate the entire structure.
- No out-of bounds errors.
   - Because the size of the generated struct is known at compile time and the struct contains a byte array of that
     size, there cannot be any out-of-bounds errors.
- Simple to use.
   - Using this crate typically involves the following simple steps:
      1. Define the data layout in a `byteview` macro.
      2. Retrieve some bytes.
      3. Create an instance of your struct with the bytes.
      4. Call one or more of the "getter" methods.
- No overhead.
   - If you have already read the bytes, then there is no overhead from creating instances of the generated structs.
     You only pay for parsing the fields you actually use at runtime.

## Limitations

- No eager parsing.
   - No bytes are parsed until they are used. This means that as long as you have enough bytes, nothing is stopping
     you from accidentally parsing data that is in completely the wrong format.
- Delayed field validation.
   - Since validation on fields is only performed when the fields are used, this can push validation errors deeper
     into your program instead of up-front before you start to use the data.
- Fields can only be primitive numeric types.
   - See the [next section](#more-than-primitive-numeric-types) for strategies on how to handle this limitation.
- Repeated validation/parsing.
   - Any parsing or validation that is done on the defined "fields" will be done every time the "getter" methods are
     called. The results of calling the "getter" methods are not cached.
- All bytes must be present when created.
   - All of the bytes must be present when instances of the generated struct are created. The generated structs do
     not support any form of streaming or partial construction. If desired, you can achieve results similar to
     streaming by creating structs for smaller "pieces" of the overall data, which can be processed independently as
     data is available.
- Size and structure must be known at compile time.
   - Neither the size nor the structure can depend on runtime data.
- No serialization.
   - Only deserialization is currently supported. Serialization may be added in the future but is not supported
     today.

## More than primitive numeric types

Although the field declarations must use primitive numeric types (or byte arrays), there are various strategies to
help deal with other types.

The general strategy is to declare a private field/"getter" method and expose a public method that parses the raw
bytes/number.

This example shows how to provide getter methods for bytes that encode a bool and an enum that look just like the
"getter" methods that return primitive numeric types.

```rust
byteview::byteview_owned! {
    struct Post {
        pub len: u32be, // This is already the appropriate type, no conversion necessary
        _is_public: u8, // This is a boolean field
        _state: u8,     // This is a State enum
    }
}

impl Post {
    // Provide a public "getter" method that returns the appropriate type (bool).
    pub fn is_public(&self) -> bool {
        // Use the private "getter" method generated by byteview_owned!
        self._is_public() == 1
    }

    // Provide a public "getter" method that returns the appropriate type (State). Since the conversion is fallible, we
    // wrap it in an Option.
    pub fn state(&self) -> Option<State> {
        // Use the private "getter" method generated by byteview_owned!
        Some(match self._state() {
            0 => State::Draft,
            1 => State::Scheduled,
            2 => State::Published,
            3 => State::Retracted,
            _ => return None,
        })
    }
}

#
let bytes = *b"\x00\x00\x00\x07\x01\x02";
let post = Post::from_array(bytes);
assert_eq!(7, post.len());
assert!(post.is_public());
assert_eq!(Some(State::Published), post.state());
```

Similar strategies can be used to include fields that are:

- Strings
   - Parse a string from a fixed-size byte array field
- Nested data structures (including other structs generated by `byteview`)
   - Parse the nested data structure from a fixed-size byte array

## Example

```rust
byteview::byteview_ref! {
    #[derive(Debug)]
    pub struct EntryHeaderRef {
        pub index: u32be, // Multi-byte primitive numeric type
        _kind: u8,        // Single byte
        _: u8,            // Single byte, unused
        _name: [u8; 16],  // Byte array
    }
}

impl<'a> EntryHeaderRef<'a> {
    pub fn kind(&self) -> Option<Kind> {
        Some(match self._kind() {
            0 => Kind::Foo,
            1 => Kind::Bar,
            2 => Kind::Baz,
            _ => return None,
        })
    }

    pub fn name(&self) -> &[u8] {
        let name = self._name();
        match name.into_iter().position(|b| *b == 0) {
            Some(i) => &name[..i],
            None => name,
        }
    }
}

#[derive(Debug, Eq, PartialEq)]
pub enum Kind {
    Foo,
    Bar,
    Baz,
}

let bytes = b"\x00\x00\x07\x01\x02\x2AMy Field Name\x00\x00\x00";
let entry_header = EntryHeaderRef::from_array(bytes);
assert_eq!(1793, entry_header.index());
assert_eq!(Some(Kind::Baz), entry_header.kind());
assert_eq!(b"My Field Name", entry_header.name());
```

## Comparison to other crates

The `byteview` crate is similar in many ways to the [`zerocopy`] crate. The biggest difference is that `zerocopy`
does eager validation of all fields, while `byteview` only does validation when the "getter" methods are called.
However, `zerocopy` provides traits that allow can allow users to define how types are deserialized with less
boilerplate than `byteview`. In addition, `zerocopy` supports both serialization and deserialization, while
`byteview` only supports deserialization.

The [`rkyv`] crate and others like it provide zero-copy deserialization but take full control of the format of the
serialized data. It cannot be used to deserialize data of arbitrary formats. `byteview` only supports
deserialization and requires the user to manually convert between any custom data types and raw bytes.

[`zerocopy`]: https://docs.rs/zerocopy/latest/zerocopy/
[`rkyv`]: https://docs.rs/rkyv/latest/rkyv/

## Other crates that may be useful

There are several other crates that you may find useful when creating a parser for a data format. Here are a few
crates with ideas for how they would be beneficial.

| Crate                          | Possible use case                                             |
| ------------------------------ | ------------------------------------------------------------- |
| [`static_assertions`]          | Assert that the size of the struct matches the expected size. |
| [`strum`] and [`strum_macros`] | Easily convert between integers and enums.                    |

[`static_assertions`]: https://crates.io/crates/static_assertions
[`strum`]: https://crates.io/crates/strum
[`strum_macros`]: https://crates.io/crates/strum_macros
